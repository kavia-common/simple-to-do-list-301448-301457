"""
Todo CRUD API Routes

This module implements all the REST API endpoints for managing todo items.
Endpoints support creating, reading, updating, and deleting todos.
"""
import sqlite3
from fastapi import APIRouter, Depends, HTTPException, status

from .database import get_db
from .schemas import (
    TodoCreate,
    TodoUpdate,
    TodoComplete,
    TodoResponse,
    TodoListResponse,
    ErrorResponse
)

router = APIRouter(prefix="/todos", tags=["Todos"])


def row_to_todo(row: sqlite3.Row) -> dict:
    """
    Convert a SQLite row to a todo dictionary
    
    Args:
        row: SQLite row from database query
        
    Returns:
        Dictionary with todo fields, converting completed from int to bool
    """
    return {
        "id": row["id"],
        "title": row["title"],
        "description": row["description"] or "",
        "completed": bool(row["completed"]),
        "created_at": row["created_at"],
        "updated_at": row["updated_at"]
    }


# PUBLIC_INTERFACE
@router.get(
    "",
    response_model=TodoListResponse,
    summary="Get all todos",
    description="Retrieve a list of all todo items in the database",
    responses={
        200: {"description": "List of todos retrieved successfully"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def get_todos(db: sqlite3.Connection = Depends(get_db)):
    """
    GET /todos - Retrieve all todo items
    
    Returns a list of all todos with their complete information including
    id, title, description, completion status, and timestamps.
    
    Args:
        db: Database connection (injected dependency)
        
    Returns:
        TodoListResponse: Object containing list of todos and total count
        
    Raises:
        HTTPException: 500 status code if database query fails
    """
    try:
        cursor = db.cursor()
        cursor.execute("""
            SELECT id, title, description, completed, created_at, updated_at
            FROM todos
            ORDER BY created_at DESC
        """)
        rows = cursor.fetchall()
        
        todos = [row_to_todo(row) for row in rows]
        
        return TodoListResponse(todos=todos, total=len(todos))
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )


# PUBLIC_INTERFACE
@router.post(
    "",
    response_model=TodoResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new todo",
    description="Create a new todo item with the provided title, description, and completion status",
    responses={
        201: {"description": "Todo created successfully"},
        400: {"model": ErrorResponse, "description": "Invalid request data"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def create_todo(todo: TodoCreate, db: sqlite3.Connection = Depends(get_db)):
    """
    POST /todos - Create a new todo item
    
    Creates a new todo with the provided information. The id and timestamps
    are automatically generated by the database.
    
    Args:
        todo: Todo creation data (title, description, completed status)
        db: Database connection (injected dependency)
        
    Returns:
        TodoResponse: The newly created todo with all fields including generated id
        
    Raises:
        HTTPException: 400 if validation fails, 500 if database operation fails
    """
    try:
        cursor = db.cursor()
        
        # Insert the new todo
        cursor.execute("""
            INSERT INTO todos (title, description, completed, created_at, updated_at)
            VALUES (?, ?, ?, datetime('now'), datetime('now'))
        """, (todo.title, todo.description or "", int(todo.completed)))
        
        # Get the newly created todo
        todo_id = cursor.lastrowid
        cursor.execute("""
            SELECT id, title, description, completed, created_at, updated_at
            FROM todos
            WHERE id = ?
        """, (todo_id,))
        
        row = cursor.fetchone()
        if not row:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to retrieve created todo"
            )
        
        return TodoResponse(**row_to_todo(row))
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )


# PUBLIC_INTERFACE
@router.get(
    "/{todo_id}",
    response_model=TodoResponse,
    summary="Get a todo by ID",
    description="Retrieve a specific todo item by its unique identifier",
    responses={
        200: {"description": "Todo retrieved successfully"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def get_todo(todo_id: int, db: sqlite3.Connection = Depends(get_db)):
    """
    GET /todos/{todo_id} - Retrieve a specific todo by ID
    
    Args:
        todo_id: Unique identifier of the todo to retrieve
        db: Database connection (injected dependency)
        
    Returns:
        TodoResponse: The requested todo item
        
    Raises:
        HTTPException: 404 if todo not found, 500 if database operation fails
    """
    try:
        cursor = db.cursor()
        cursor.execute("""
            SELECT id, title, description, completed, created_at, updated_at
            FROM todos
            WHERE id = ?
        """, (todo_id,))
        
        row = cursor.fetchone()
        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Todo with id {todo_id} not found"
            )
        
        return TodoResponse(**row_to_todo(row))
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )


# PUBLIC_INTERFACE
@router.put(
    "/{todo_id}",
    response_model=TodoResponse,
    summary="Update a todo",
    description="Update an existing todo item with new values. All provided fields will be updated.",
    responses={
        200: {"description": "Todo updated successfully"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        400: {"model": ErrorResponse, "description": "Invalid request data"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def update_todo(todo_id: int, todo: TodoUpdate, db: sqlite3.Connection = Depends(get_db)):
    """
    PUT /todos/{todo_id} - Update an existing todo
    
    Updates the specified todo with the provided values. Only the fields
    that are provided will be updated. The updated_at timestamp is automatically set.
    
    Args:
        todo_id: Unique identifier of the todo to update
        todo: Update data (title, description, and/or completed status)
        db: Database connection (injected dependency)
        
    Returns:
        TodoResponse: The updated todo item
        
    Raises:
        HTTPException: 404 if todo not found, 400 if validation fails, 500 if database operation fails
    """
    try:
        cursor = db.cursor()
        
        # Check if todo exists
        cursor.execute("SELECT id FROM todos WHERE id = ?", (todo_id,))
        if not cursor.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Todo with id {todo_id} not found"
            )
        
        # Build update query dynamically based on provided fields
        update_fields = []
        params = []
        
        if todo.title is not None:
            update_fields.append("title = ?")
            params.append(todo.title)
        
        if todo.description is not None:
            update_fields.append("description = ?")
            params.append(todo.description)
        
        if todo.completed is not None:
            update_fields.append("completed = ?")
            params.append(int(todo.completed))
        
        if not update_fields:
            # No fields to update, just return the current todo
            cursor.execute("""
                SELECT id, title, description, completed, created_at, updated_at
                FROM todos
                WHERE id = ?
            """, (todo_id,))
            row = cursor.fetchone()
            return TodoResponse(**row_to_todo(row))
        
        # Always update the updated_at timestamp
        update_fields.append("updated_at = datetime('now')")
        params.append(todo_id)
        
        # Execute update
        query = f"UPDATE todos SET {', '.join(update_fields)} WHERE id = ?"
        cursor.execute(query, params)
        
        # Get updated todo
        cursor.execute("""
            SELECT id, title, description, completed, created_at, updated_at
            FROM todos
            WHERE id = ?
        """, (todo_id,))
        
        row = cursor.fetchone()
        return TodoResponse(**row_to_todo(row))
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )


# PUBLIC_INTERFACE
@router.patch(
    "/{todo_id}/complete",
    response_model=TodoResponse,
    summary="Mark todo as complete/incomplete",
    description="Toggle or set the completion status of a todo item",
    responses={
        200: {"description": "Todo completion status updated successfully"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def complete_todo(todo_id: int, completion: TodoComplete, db: sqlite3.Connection = Depends(get_db)):
    """
    PATCH /todos/{todo_id}/complete - Mark a todo as complete or incomplete
    
    Updates only the completion status of a todo. This is a convenience endpoint
    for toggling todo completion without updating other fields.
    
    Args:
        todo_id: Unique identifier of the todo to update
        completion: Object containing the new completion status
        db: Database connection (injected dependency)
        
    Returns:
        TodoResponse: The updated todo item
        
    Raises:
        HTTPException: 404 if todo not found, 500 if database operation fails
    """
    try:
        cursor = db.cursor()
        
        # Check if todo exists
        cursor.execute("SELECT id FROM todos WHERE id = ?", (todo_id,))
        if not cursor.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Todo with id {todo_id} not found"
            )
        
        # Update completion status
        cursor.execute("""
            UPDATE todos
            SET completed = ?, updated_at = datetime('now')
            WHERE id = ?
        """, (int(completion.completed), todo_id))
        
        # Get updated todo
        cursor.execute("""
            SELECT id, title, description, completed, created_at, updated_at
            FROM todos
            WHERE id = ?
        """, (todo_id,))
        
        row = cursor.fetchone()
        return TodoResponse(**row_to_todo(row))
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )


# PUBLIC_INTERFACE
@router.delete(
    "/{todo_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a todo",
    description="Delete a todo item permanently from the database",
    responses={
        204: {"description": "Todo deleted successfully"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
def delete_todo(todo_id: int, db: sqlite3.Connection = Depends(get_db)):
    """
    DELETE /todos/{todo_id} - Delete a todo item
    
    Permanently removes a todo from the database. This operation cannot be undone.
    
    Args:
        todo_id: Unique identifier of the todo to delete
        db: Database connection (injected dependency)
        
    Returns:
        None (204 No Content status)
        
    Raises:
        HTTPException: 404 if todo not found, 500 if database operation fails
    """
    try:
        cursor = db.cursor()
        
        # Check if todo exists
        cursor.execute("SELECT id FROM todos WHERE id = ?", (todo_id,))
        if not cursor.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Todo with id {todo_id} not found"
            )
        
        # Delete the todo
        cursor.execute("DELETE FROM todos WHERE id = ?", (todo_id,))
        
        return None
    except sqlite3.Error as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error: {str(e)}"
        )
